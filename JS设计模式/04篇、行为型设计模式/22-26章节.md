## <div id="class04">第四篇、行为型设计模式</div>

### <div id="class04-22">22章、访问者模式</div>
定义个绑定事件， 但是在低版本浏览器中会报错。
```js
let bindEvent = function (dom, type, fn) {
    if(dom.addEventListener) {
        dom.addEventListener(type, fn, false);
    } else if(dom.attachEvent) {
        dom.attachEvent('on'+ type, fn);
    } else {
        dom['on'+ type] = fn;
    }
};


/**
 * 下面的在IE低版本浏览器运行会有问题
 * 这个地方运行就有问题了，因为this.style 中的this 在低版本IE中，指向的是window对象
 * @type {HTMLElement | null}
 */
let demo = document.getElementById('dome');
bindEvent(demo, 'click', function () {
    this.style.background = 'red';
});
```
[对象访问器的一个示例](./22章、访问者模式/02、对象访问器.js)


### <div id="class04-23">23章、中介者模式</div>
通过中介者对象封装一些列对象之间的交互，是对象之间不再相互引用，降低耦合度。有的时候也可以改变对象之间的交互。

跟观察者模式的区别：                       
首先他们都是通过消息收发机制实现的，不过在观察者模式中，一个对象既可以是消费者的发送者，也可以是消息的接受者，他们之间的信息交流依托于消息系统之间的解耦。                       
中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息， 只能那些活跃对象(订阅者)才能订阅中介者的消息。

代码示例如下： [01、创建中介者对象](23、中介者模式/01、创建中介者对象.js)                            
一个实际场景的使用：[02、一个完整的使用场景](./23、中介者模式/02、一个完整的使用场景.js)


### <div id="class04-24">24章、备忘录模式</div>
描述：                         
在不破坏对象的封装性的前提下， 在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象回复到以前的某个状态。

实际场景：                   
有这么一个场景， 就是在分页中， 用户点击下一页的时候， 就去去请求数据， 但是又点回上一页的时候， 大多数的操作还是请求上一页数据。
这样的操作就会导致多余的请求。为了避免这种多余的请求， 我们就可以做缓存数据。

示例： [01、新闻缓存器](./24、备忘录模式/01、新闻缓存器.js)


### <div id="class04-25">25章、迭代器模式</div>
描述：                     
在不暴露对象内部结构的同时， 可以顺序的访问聚合对象的元素。

代码示例：               
[01、迭代器的实现](./25、迭代器模式/01、迭代器的实现.js)                            


### <div id="class04-26">26章、解释器</div>
描述：                 
用一些描述性的语句， 几次功能的提取抽象， 形成一套语法规则， 这就是解释器要处理的事情。

代码示例：                       
[01、Interpreter](./26、解释器模式/01、Interpreter.js)





 
